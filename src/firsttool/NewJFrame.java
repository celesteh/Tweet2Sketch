package firsttool;

import firsttool.ServiceLocator.ServiceRecord;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import javax.swing.JButton;
import javax.swing.ListModel;
import javax.swing.Timer;

/**
 *
 * @author Dimitry Kireyenkov <dimitry@languagekings.com>
 */
public class NewJFrame extends javax.swing.JFrame {

    IQueueAccessPoint mQueueAccessPoint;
    private final Timer timer;
    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
        mQueueAccessPoint = startTweetFetchService(); // we start thread, but we don't
                                                     // care much about the fact that it's thread
                                                     // fetching. All we care is that 
                                                     // we get reference to IQueueAccessPoint
                                                     // which we can poll at any time (thead safe)
                                                     // and we can get latest items.
 
        // now we need to start timer. this timer will call every now and then and will be firing ON SWING THREAD
        // when there's availble tweet.
        timer = new Timer(1000, new ActionListener() {  // technically we don't need update more frequently than thred is updating, but that doesn't matter.
            @Override
            public void actionPerformed(ActionEvent e) {
                ArrayList<AbstractTweet> arlis = null;
                AbstractTweet aTweet = null;
                while ( ( aTweet = mQueueAccessPoint.getNextOrNull() ) != null ){
                    if ( arlis == null ){ arlis = new ArrayList<AbstractTweet>(); }
                    arlis.add(aTweet);
                }
                
                if ( arlis != null){
                    fireNewTweetsEvent(arlis);
                }
            }
        });
        
        timer.setInitialDelay(500); // wait half a second, util we set up the thing
        timer.start();
    }

    // -------------------------------------------------------------------------------
    /**
     * This is interface observer may subscribe to.
     */
    interface IOnNewTweetsListener
    {
        void onNewTweets(ArrayList<AbstractTweet> newTweets);
    }
    
    
    private IOnNewTweetsListener mOnNewTweetsListener;
    
    protected void fireNewTweetsEvent(ArrayList<AbstractTweet> newTweets){
         if ( mOnNewTweetsListener != null ){
                mOnNewTweetsListener.onNewTweets(newTweets);
         }
    }
    
    void setOnNewTweetsListener(IOnNewTweetsListener listener){
         mOnNewTweetsListener = listener;
    }
    // --------------------------------------------------------------------------------

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jLabel1 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jList1.setModel(new javax.swing.AbstractListModel() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(jList1);

        jLabel1.setText("Tweets");

        jButton1.setText("Insert into PDE");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addGap(92, 92, 92)
                .addComponent(jButton1)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGap(19, 19, 19)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 1011, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(9, 9, 9)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jButton1))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 501, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(24, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JList jList1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables

    protected void setListModel(ListModel lmodel){
        jList1.setModel(lmodel);
    }

//    // there's no need to keep this reference here.
//    // as NewJFrame only thinks of this as IQueueAccessPoint
//    // and doesn't care of it's implementation. NewjFrame simply knows
//    // that it should poll at regular intervals the queue. but how it's 
//    // implemented it's not his business.
//    /**
//     * This is the thread which is doing the polling job.
//     */
//    protected TweetFetchThread thread;
    
    private IQueueAccessPoint startTweetFetchService() {
//        TweetFetchThread thread = new TweetFetchThread();
//        thread.start();
//        return thread;
        ServiceRecord service = ServiceLocator.getSerivce(ServiceLocator.SVC_LIVE_TWEET_QUEUE);
        return (IQueueAccessPoint) service;  // yeah we have cast here, but hurray! we're decoupled
                                             // now from instantiation of the service
    }
    
    /**
     * Our super class knows that INCUIM we use
     * button as a way to select tweet.
     * TODO: need to make these abstraction layers more clear. 
     * Maybe need to draw a diagram.
     * @return 
     */
    protected JButton getSelectButton(){
        return jButton1;
    }
    

    /**
     * Just returns selected in the list tweet. Or null
     * @return  NULL on nothing selected or error casting.
     */
    protected AbstractTweet getSelectedInListTweet() {
        Object selection = jList1.getSelectedValue();
        if ( selection == null ){ 
            return null;
        }
        if  ( selection instanceof AbstractTweet ){
            return (AbstractTweet) selection;
        }
        System.out.println("Error casting JList element to AbstractTweet. Probably just string was in the list");
        return null;
    }
    
    
}
